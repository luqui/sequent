Introduction
------------

This is a programming language designed around the principle that you construct
programs as in Coq's proof mode.

You manipulate both knowledge and variables.  But knowledge manipultion is soft;
you can claim things without proof, assuming you document them.

The code itself is not made to be especially readable.  In fact, the code itself
should almost be absent, like the strokes of an artist, leaving only the
result to represent what the code did.

Signatures play the role of functions in this language. A signature specifies
inputs and outputs, including names and knowledge.

The following three propositions form the definition of Divides.  When asked
for a proof, they will be "proved by definition"; i.e.  moved into the
assumptions when `Divides` is quantified over. (We will talk about numerals
and the `*` symbol later).

    x :nat   -> [1 Divides x]

    x :nat   -> [x Divides 0]

    x y :nat -> [x Divides x*y]

We then define a division with remainder theorem:

    x y :nat -> q r :nat [x = q*y + r] [r < y]

This theorem has outputs (`q` and `r`) which must be computed, so you cannot
simply prove by definition.  You can give expressions for `q` and `r`, however,
and then explain the two returned properties in documentation. I don't know how
yet.

Finally, a `gcd` theorem.  This also returns a witness so it needs a
computation and cannot simply be explained.  However, with what we have built
up, we can compute it without any appeal to an underlying language.

    x y :nat
    ->
    gcd :nat
    [gcd Divides x] [gcd Divides y] 
    ( [d' Divides x] [d' Divides y] -> [d' Divides gcd] )

The witness from applying this theorem can be referred to as `gcd(x,y)`. It
introduces obligations for `x:nat` and `y:nat`, and produces the knowledge
`[gcd(x,y) Divides x]`, etc.

Similarly, the division algorithm can be referred to as `q(x,y)` and `r(x,y)`,
if left defined as above.  When one is applied, the suitably skolemized other
is introduced into the context with it.  However, with these uninstructive
names, we want to give it some context, so we can label the theorem:

    division:
    x y :nat -> q r :nat [x = q*y + r] [r < y]

Now `q` and `r` may not be referred to as skolem functions.  They may still be
introduced by existential destruction.  There ought to be another notation for
introduing them in a theorem body, but I can't think of one right now.

Signature Syntax
----------------

A *clause* of a signature is a set of terms, which are variables and
propositions.  The terms are separated by spaces.  A term may be:

* A proposition, which is surrounded in square brackets.  Propositions have
    a free-form syntax, in which the name of the proposition can go between
    its arguments.  For example `[x divides y]` is an example usage or definition
    of the proposition `[_ divides _]`.  What count as variables and what count
    as structure depends on the surrounding quantification.  Parentheses occurring
    in the syntax of a proposition ensure that that position is interpreted
    as an expression. 
* A variable clause, which is a list of variables (as barewords) followed by a
    list of types (each introduced with a colon).  A type is shorthand for a
    proposition: `x :nat` is shorthand for `[nat x]`. The spaces are interpreted
    as part of the type until the next colon or opening bracket, so: 
    `x y : list nat : sorted` is short for the propositions `[list nat x]`,
    `[sorted x]`, `[list nat y]`, `[sorted y]`.

A signature is:

* A clause
* An implication: `P -> Q`, where `P` and `Q` are clauses.

Implication is *non*-associative, you have to insert parentheses to nest
them.  Parentheses should be minimal, because of the conjunctive properties
of clauses.

We can now see how the `gcd` definition might be interpreted:

    x y :int [x > 0] [y > 0]
    -> 
    gcd :int [gcd > 0] [gcd divides x] [gcd divides y]

However, the quantifiers are still unclear.

Quantification
--------------

Signatures are formulas in a logical calculus (it is unclear which one exactly,
and it is rather unimportant because consistency is not necessary).  As such,
the variables in theorems are quantified by universal and existential
quantifiers.  These quantifiers and their destructors are the basis of data
manipulation in sequent.

Every variable in a variable clause is quantified.  The quantification depends
on the position of the variable clause.

* If it occurs to the immediate left of an implication clause, then the
    quantification is universal.  `x y : nat -> ...` means 
    `forall x, forall y, [nat x] [nat y], ...`.
* If not, then the quantification is existential (which, as we will see later,
    introduces a Skolem function). `x : nat -> y : nat` means 
    `forall x, [nat x] -> exists y, [nat y]`.

Skolem Functions
----------------

Every existential quantifier introduces a Skolem function 
